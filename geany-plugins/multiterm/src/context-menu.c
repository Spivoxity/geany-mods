/* context-menu.c generated by valac 0.34.9, the Vala compiler
 * generated from context-menu.vala, do not modify */

/*
 * context-menu.vala - This file is part of the Geany MultiTerm plugin
 *
 * Copyright (c) 2012 Matthew Brush <matt@geany.org>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "multiterm.h"
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <stdlib.h>
#include <string.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
#define _multi_term_shell_config_unref0(var) ((var == NULL) ? NULL : (var = (multi_term_shell_config_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Block1Data {
	int _ref_count_;
	MultiTermContextMenu* self;
	GtkMenuItem* item;
	GtkCheckMenuItem* check_item;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	MultiTermShellConfig* sh;
};


static gpointer multi_term_context_menu_parent_class = NULL;

enum  {
	MULTI_TERM_CONTEXT_MENU_DUMMY_PROPERTY
};
static void multi_term_context_menu_on_show_tabs_activate (MultiTermContextMenu* self, GtkCheckMenuItem* item);
static void multi_term_context_menu_on_next_previous_tab_activate (MultiTermContextMenu* self, GtkMenuItem* item, gboolean next);
static void multi_term_context_menu_on_move_to_location (MultiTermContextMenu* self, GtkMenuItem* item);
static void multi_term_context_menu_add_separator (MultiTermContextMenu* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void _____lambda5_ (Block2Data* _data2_);
static void ______lambda5__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda6_ (MultiTermContextMenu* self);
static void ___lambda6__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda7_ (Block1Data* _data1_);
static void ___lambda7__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda8_ (Block1Data* _data1_);
static void ___lambda8__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda9_ (MultiTermContextMenu* self);
static void ___lambda9__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda10_ (MultiTermContextMenu* self);
static void ___lambda10__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda11_ (Block1Data* _data1_);
static void ___lambda11__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda12_ (Block1Data* _data1_);
static void ___lambda12__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda13_ (MultiTermContextMenu* self);
static void ___lambda13__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void g_cclosure_user_marshal_VOID__MULTI_TERM_SHELL_CONFIG (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);


static void multi_term_context_menu_on_show_tabs_activate (MultiTermContextMenu* self, GtkCheckMenuItem* item) {
	GtkCheckMenuItem* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = item;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	g_signal_emit_by_name (self, "show-tabs-activate", _tmp2_);
}


static void multi_term_context_menu_on_next_previous_tab_activate (MultiTermContextMenu* self, GtkMenuItem* item, gboolean next) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GtkMenuItem* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp1_ = next;
	if (_tmp1_) {
		gboolean _tmp2_ = FALSE;
		g_signal_emit_by_name (self, "next-tab-activate", &_tmp2_);
		_tmp0_ = _tmp2_;
	} else {
		gboolean _tmp3_ = FALSE;
		g_signal_emit_by_name (self, "previous-tab-activate", &_tmp3_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = item;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp4_, _tmp0_);
}


static void multi_term_context_menu_on_move_to_location (MultiTermContextMenu* self, GtkMenuItem* item) {
	GtkMenuItem* _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = item;
	_tmp1_ = g_object_get_data ((GObject*) _tmp0_, "location_is_msgwin");
	if ((gboolean) ((gintptr) _tmp1_)) {
		GtkMenuItem* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		GtkMenuItem* _tmp4_ = NULL;
		_tmp2_ = item;
		_tmp3_ = _ ("Move to message window");
		gtk_menu_item_set_label (_tmp2_, _tmp3_);
		_tmp4_ = item;
		g_object_set_data_full ((GObject*) _tmp4_, "location_is_msgwin", (gpointer) ((gintptr) FALSE), NULL);
		g_signal_emit_by_name (self, "move-to-location-activate", "sidebar");
	} else {
		GtkMenuItem* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		GtkMenuItem* _tmp7_ = NULL;
		_tmp5_ = item;
		_tmp6_ = _ ("Move to sidebar");
		gtk_menu_item_set_label (_tmp5_, _tmp6_);
		_tmp7_ = item;
		g_object_set_data_full ((GObject*) _tmp7_, "location_is_msgwin", (gpointer) ((gintptr) TRUE), NULL);
		g_signal_emit_by_name (self, "move-to-location-activate", "msgwin");
	}
}


static void multi_term_context_menu_add_separator (MultiTermContextMenu* self) {
	GtkSeparatorMenuItem* item = NULL;
	GtkSeparatorMenuItem* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp0_);
	item = _tmp0_;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) ((GtkMenuItem*) item));
	gtk_widget_show ((GtkWidget*) item);
	_g_object_unref0 (item);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		MultiTermContextMenu* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->check_item);
		_g_object_unref0 (_data1_->item);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		MultiTermContextMenu* self;
		self = _data2_->_data1_->self;
		_multi_term_shell_config_unref0 (_data2_->sh);
		block1_data_unref (_data2_->_data1_);
		_data2_->_data1_ = NULL;
		g_slice_free (Block2Data, _data2_);
	}
}


static gpointer _multi_term_shell_config_ref0 (gpointer self) {
	return self ? multi_term_shell_config_ref (self) : NULL;
}


static void _____lambda5_ (Block2Data* _data2_) {
	Block1Data* _data1_;
	MultiTermContextMenu* self;
	MultiTermShellConfig* _tmp0_ = NULL;
	_data1_ = _data2_->_data1_;
	self = _data1_->self;
	_tmp0_ = _data2_->sh;
	g_signal_emit_by_name (self, "new-shell-activate", _tmp0_);
}


static void ______lambda5__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	_____lambda5_ (self);
}


static void __lambda6_ (MultiTermContextMenu* self) {
	g_signal_emit_by_name (self, "new-window-activate");
}


static void ___lambda6__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda6_ ((MultiTermContextMenu*) self);
}


static void __lambda7_ (Block1Data* _data1_) {
	MultiTermContextMenu* self;
	GtkMenuItem* _tmp0_ = NULL;
	self = _data1_->self;
	_tmp0_ = _data1_->item;
	multi_term_context_menu_on_next_previous_tab_activate (self, _tmp0_, TRUE);
}


static void ___lambda7__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda7_ (self);
}


static void __lambda8_ (Block1Data* _data1_) {
	MultiTermContextMenu* self;
	GtkMenuItem* _tmp0_ = NULL;
	self = _data1_->self;
	_tmp0_ = _data1_->item;
	multi_term_context_menu_on_next_previous_tab_activate (self, _tmp0_, FALSE);
}


static void ___lambda8__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda8_ (self);
}


static void __lambda9_ (MultiTermContextMenu* self) {
	g_signal_emit_by_name (self, "copy-activate");
}


static void ___lambda9__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda9_ ((MultiTermContextMenu*) self);
}


static void __lambda10_ (MultiTermContextMenu* self) {
	g_signal_emit_by_name (self, "paste-activate");
}


static void ___lambda10__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda10_ ((MultiTermContextMenu*) self);
}


static void __lambda11_ (Block1Data* _data1_) {
	MultiTermContextMenu* self;
	GtkCheckMenuItem* _tmp0_ = NULL;
	self = _data1_->self;
	_tmp0_ = _data1_->check_item;
	multi_term_context_menu_on_show_tabs_activate (self, _tmp0_);
}


static void ___lambda11__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda11_ (self);
}


static void __lambda12_ (Block1Data* _data1_) {
	MultiTermContextMenu* self;
	GtkMenuItem* _tmp0_ = NULL;
	self = _data1_->self;
	_tmp0_ = _data1_->item;
	multi_term_context_menu_on_move_to_location (self, _tmp0_);
}


static void ___lambda12__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda12_ (self);
}


static void __lambda13_ (MultiTermContextMenu* self) {
	g_signal_emit_by_name (self, "preferences-activate");
}


static void ___lambda13__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda13_ ((MultiTermContextMenu*) self);
}


MultiTermContextMenu* multi_term_context_menu_construct (GType object_type, MultiTermConfig* cfg) {
	MultiTermContextMenu * self = NULL;
	Block1Data* _data1_;
	GtkMenu* menu = NULL;
	GtkImageMenuItem* image_item = NULL;
	GtkMenu* _tmp0_ = NULL;
	GtkMenu* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkMenuItem* _tmp3_ = NULL;
	GtkMenuItem* _tmp4_ = NULL;
	GtkMenu* _tmp5_ = NULL;
	GtkMenuItem* _tmp6_ = NULL;
	GtkMenuItem* _tmp7_ = NULL;
	guint len = 0U;
	MultiTermConfig* _tmp8_ = NULL;
	GList* _tmp9_ = NULL;
	GList* _tmp10_ = NULL;
	guint _tmp11_ = 0U;
	const gchar* _tmp31_ = NULL;
	GtkMenuItem* _tmp32_ = NULL;
	GtkMenuItem* _tmp33_ = NULL;
	GtkMenuItem* _tmp34_ = NULL;
	GtkMenuItem* _tmp35_ = NULL;
	const gchar* _tmp36_ = NULL;
	GtkMenuItem* _tmp37_ = NULL;
	GtkMenuItem* _tmp38_ = NULL;
	const gchar* _tmp39_ = NULL;
	GtkMenuItem* _tmp40_ = NULL;
	GtkMenuItem* _tmp41_ = NULL;
	GtkImageMenuItem* _tmp42_ = NULL;
	GtkImageMenuItem* _tmp43_ = NULL;
	GtkImageMenuItem* _tmp44_ = NULL;
	GtkImageMenuItem* _tmp45_ = NULL;
	const gchar* _tmp46_ = NULL;
	GtkCheckMenuItem* _tmp47_ = NULL;
	GtkCheckMenuItem* _tmp48_ = NULL;
	MultiTermConfig* _tmp49_ = NULL;
	gboolean _tmp50_ = FALSE;
	gboolean _tmp51_ = FALSE;
	GtkCheckMenuItem* _tmp52_ = NULL;
	GtkCheckMenuItem* _tmp53_ = NULL;
	GtkCheckMenuItem* _tmp54_ = NULL;
	MultiTermConfig* _tmp55_ = NULL;
	gchar* _tmp56_ = NULL;
	gchar* _tmp57_ = NULL;
	gchar* _tmp58_ = NULL;
	gboolean _tmp59_ = FALSE;
	GtkMenuItem* _tmp66_ = NULL;
	GtkMenuItem* _tmp67_ = NULL;
	GtkMenuItem* _tmp68_ = NULL;
	GtkImageMenuItem* _tmp69_ = NULL;
	GtkImageMenuItem* _tmp70_ = NULL;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (MultiTermContextMenu*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (menu);
	menu = _tmp0_;
	_tmp1_ = menu;
	gtk_widget_show ((GtkWidget*) _tmp1_);
	_tmp2_ = _ ("Open Tab");
	_tmp3_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp2_);
	g_object_ref_sink (_tmp3_);
	_g_object_unref0 (_data1_->item);
	_data1_->item = _tmp3_;
	_tmp4_ = _data1_->item;
	_tmp5_ = menu;
	gtk_menu_item_set_submenu (_tmp4_, (GtkWidget*) _tmp5_);
	_tmp6_ = _data1_->item;
	gtk_widget_show ((GtkWidget*) _tmp6_);
	_tmp7_ = _data1_->item;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) _tmp7_);
	_tmp8_ = cfg;
	_tmp9_ = multi_term_config_get_shell_configs (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_list_length (_tmp10_);
	len = _tmp11_;
	{
		guint i = 0U;
		i = (guint) 0;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				Block2Data* _data2_;
				guint _tmp14_ = 0U;
				guint _tmp15_ = 0U;
				MultiTermConfig* _tmp16_ = NULL;
				GList* _tmp17_ = NULL;
				GList* _tmp18_ = NULL;
				guint _tmp19_ = 0U;
				gconstpointer _tmp20_ = NULL;
				MultiTermShellConfig* _tmp21_ = NULL;
				MultiTermShellConfig* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				GtkMenuItem* _tmp26_ = NULL;
				GtkMenuItem* _tmp27_ = NULL;
				GtkMenu* _tmp28_ = NULL;
				GtkMenuItem* _tmp29_ = NULL;
				GtkMenuItem* _tmp30_ = NULL;
				_data2_ = g_slice_new0 (Block2Data);
				_data2_->_ref_count_ = 1;
				_data2_->_data1_ = block1_data_ref (_data1_);
				if (!_tmp12_) {
					guint _tmp13_ = 0U;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = len;
				if (!(_tmp14_ < _tmp15_)) {
					block2_data_unref (_data2_);
					_data2_ = NULL;
					break;
				}
				_tmp16_ = cfg;
				_tmp17_ = multi_term_config_get_shell_configs (_tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = i;
				_tmp20_ = g_list_nth_data (_tmp18_, _tmp19_);
				_tmp21_ = _multi_term_shell_config_ref0 ((MultiTermShellConfig*) _tmp20_);
				_data2_->sh = _tmp21_;
				_tmp22_ = _data2_->sh;
				_tmp23_ = multi_term_shell_config_get_name (_tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = _tmp24_;
				_tmp26_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp25_);
				g_object_ref_sink (_tmp26_);
				_g_object_unref0 (_data1_->item);
				_data1_->item = _tmp26_;
				_g_free0 (_tmp25_);
				_tmp27_ = _data1_->item;
				g_signal_connect_data (_tmp27_, "activate", (GCallback) ______lambda5__gtk_menu_item_activate, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
				_tmp28_ = menu;
				_tmp29_ = _data1_->item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp28_, (GtkWidget*) _tmp29_);
				_tmp30_ = _data1_->item;
				gtk_widget_show ((GtkWidget*) _tmp30_);
				block2_data_unref (_data2_);
				_data2_ = NULL;
			}
		}
	}
	_tmp31_ = _ ("Open Window");
	_tmp32_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp31_);
	g_object_ref_sink (_tmp32_);
	_g_object_unref0 (_data1_->item);
	_data1_->item = _tmp32_;
	_tmp33_ = _data1_->item;
	g_signal_connect_object (_tmp33_, "activate", (GCallback) ___lambda6__gtk_menu_item_activate, self, 0);
	_tmp34_ = _data1_->item;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) _tmp34_);
	_tmp35_ = _data1_->item;
	gtk_widget_show ((GtkWidget*) _tmp35_);
	multi_term_context_menu_add_separator (self);
	_tmp36_ = _ ("Next tab");
	_tmp37_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp36_);
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (_data1_->item);
	_data1_->item = _tmp37_;
	_tmp38_ = _data1_->item;
	g_signal_connect_data (_tmp38_, "activate", (GCallback) ___lambda7__gtk_menu_item_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp39_ = _ ("Previous tab");
	_tmp40_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp39_);
	g_object_ref_sink (_tmp40_);
	_g_object_unref0 (_data1_->item);
	_data1_->item = _tmp40_;
	_tmp41_ = _data1_->item;
	g_signal_connect_data (_tmp41_, "activate", (GCallback) ___lambda8__gtk_menu_item_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp42_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_COPY, NULL);
	g_object_ref_sink (_tmp42_);
	_g_object_unref0 (image_item);
	image_item = _tmp42_;
	_tmp43_ = image_item;
	g_signal_connect_object ((GtkMenuItem*) _tmp43_, "activate", (GCallback) ___lambda9__gtk_menu_item_activate, self, 0);
	_tmp44_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_PASTE, NULL);
	g_object_ref_sink (_tmp44_);
	_g_object_unref0 (image_item);
	image_item = _tmp44_;
	_tmp45_ = image_item;
	g_signal_connect_object ((GtkMenuItem*) _tmp45_, "activate", (GCallback) ___lambda10__gtk_menu_item_activate, self, 0);
	_tmp46_ = _ ("Show Tabs");
	_tmp47_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_tmp46_);
	g_object_ref_sink (_tmp47_);
	_g_object_unref0 (_data1_->check_item);
	_data1_->check_item = _tmp47_;
	_tmp48_ = _data1_->check_item;
	_tmp49_ = cfg;
	_tmp50_ = multi_term_config_get_show_tabs (_tmp49_);
	_tmp51_ = _tmp50_;
	gtk_check_menu_item_set_active (_tmp48_, _tmp51_);
	_tmp52_ = _data1_->check_item;
	g_signal_connect_data ((GtkMenuItem*) _tmp52_, "activate", (GCallback) ___lambda11__gtk_menu_item_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp53_ = _data1_->check_item;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) ((GtkMenuItem*) _tmp53_));
	_tmp54_ = _data1_->check_item;
	gtk_widget_show ((GtkWidget*) _tmp54_);
	_tmp55_ = cfg;
	_tmp56_ = multi_term_config_get_location (_tmp55_);
	_tmp57_ = _tmp56_;
	_tmp58_ = _tmp57_;
	_tmp59_ = g_strcmp0 (_tmp58_, "msgwin") == 0;
	_g_free0 (_tmp58_);
	if (_tmp59_) {
		const gchar* _tmp60_ = NULL;
		GtkMenuItem* _tmp61_ = NULL;
		GtkMenuItem* _tmp62_ = NULL;
		_tmp60_ = _ ("Move to sidebar");
		_tmp61_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp60_);
		g_object_ref_sink (_tmp61_);
		_g_object_unref0 (_data1_->item);
		_data1_->item = _tmp61_;
		_tmp62_ = _data1_->item;
		g_object_set_data_full ((GObject*) _tmp62_, "location_is_msgwin", (gpointer) ((gintptr) TRUE), NULL);
	} else {
		const gchar* _tmp63_ = NULL;
		GtkMenuItem* _tmp64_ = NULL;
		GtkMenuItem* _tmp65_ = NULL;
		_tmp63_ = _ ("Move to message window");
		_tmp64_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp63_);
		g_object_ref_sink (_tmp64_);
		_g_object_unref0 (_data1_->item);
		_data1_->item = _tmp64_;
		_tmp65_ = _data1_->item;
		g_object_set_data_full ((GObject*) _tmp65_, "location_is_msgwin", (gpointer) ((gintptr) FALSE), NULL);
	}
	_tmp66_ = _data1_->item;
	g_signal_connect_data (_tmp66_, "activate", (GCallback) ___lambda12__gtk_menu_item_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp67_ = _data1_->item;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) _tmp67_);
	_tmp68_ = _data1_->item;
	gtk_widget_show ((GtkWidget*) _tmp68_);
	_tmp69_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_PREFERENCES, NULL);
	g_object_ref_sink (_tmp69_);
	_g_object_unref0 (image_item);
	image_item = _tmp69_;
	_tmp70_ = image_item;
	g_signal_connect_object ((GtkMenuItem*) _tmp70_, "activate", (GCallback) ___lambda13__gtk_menu_item_activate, self, 0);
	_g_object_unref0 (image_item);
	_g_object_unref0 (menu);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


MultiTermContextMenu* multi_term_context_menu_new (MultiTermConfig* cfg) {
	return multi_term_context_menu_construct (MULTI_TERM_TYPE_CONTEXT_MENU, cfg);
}


static void g_cclosure_user_marshal_VOID__MULTI_TERM_SHELL_CONFIG (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__MULTI_TERM_SHELL_CONFIG) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__MULTI_TERM_SHELL_CONFIG callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__MULTI_TERM_SHELL_CONFIG) (marshal_data ? marshal_data : cc->callback);
	callback (data1, multi_term_value_get_shell_config (param_values + 1), data2);
}


static void g_cclosure_user_marshal_BOOLEAN__VOID (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef gboolean (*GMarshalFunc_BOOLEAN__VOID) (gpointer data1, gpointer data2);
	register GMarshalFunc_BOOLEAN__VOID callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gboolean v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 1);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_BOOLEAN__VOID) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, data2);
	g_value_set_boolean (return_value, v_return);
}


static void multi_term_context_menu_class_init (MultiTermContextMenuClass * klass) {
	multi_term_context_menu_parent_class = g_type_class_peek_parent (klass);
	g_signal_new ("new_shell_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__MULTI_TERM_SHELL_CONFIG, G_TYPE_NONE, 1, MULTI_TERM_TYPE_SHELL_CONFIG);
	g_signal_new ("new_window_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("copy_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("paste_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("show_tabs_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
	g_signal_new ("preferences_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("next_tab_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__VOID, G_TYPE_BOOLEAN, 0);
	g_signal_new ("previous_tab_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_BOOLEAN__VOID, G_TYPE_BOOLEAN, 0);
	g_signal_new ("move_to_location_activate", MULTI_TERM_TYPE_CONTEXT_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void multi_term_context_menu_instance_init (MultiTermContextMenu * self) {
}


GType multi_term_context_menu_get_type (void) {
	static volatile gsize multi_term_context_menu_type_id__volatile = 0;
	if (g_once_init_enter (&multi_term_context_menu_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiTermContextMenuClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_term_context_menu_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiTermContextMenu), 0, (GInstanceInitFunc) multi_term_context_menu_instance_init, NULL };
		GType multi_term_context_menu_type_id;
		multi_term_context_menu_type_id = g_type_register_static (GTK_TYPE_MENU, "MultiTermContextMenu", &g_define_type_info, 0);
		g_once_init_leave (&multi_term_context_menu_type_id__volatile, multi_term_context_menu_type_id);
	}
	return multi_term_context_menu_type_id__volatile;
}



