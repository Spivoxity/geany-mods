/* config.c generated by valac 0.34.9, the Vala compiler
 * generated from config.vala, do not modify */

/*
 * config.vala - This file is part of the Geany MultiTerm plugin
 *
 * Copyright (c) 2012 Matthew Brush <matt@geany.org>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "multiterm.h"
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <glib/gi18n-lib.h>
#include <gobject/gvaluecollector.h>

#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__multi_term_shell_config_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__multi_term_shell_config_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _MultiTermParamSpecConfig MultiTermParamSpecConfig;

struct _MultiTermConfigPrivate {
	gchar* _filename;
	GList* _shell_configs;
};

struct _MultiTermParamSpecConfig {
	GParamSpec parent_instance;
};


static gpointer multi_term_config_parent_class = NULL;

#define MULTI_TERM_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MULTI_TERM_TYPE_CONFIG, MultiTermConfigPrivate))
enum  {
	MULTI_TERM_CONFIG_DUMMY_PROPERTY
};
static void _multi_term_shell_config_unref0_ (gpointer var);
static void _g_list_free__multi_term_shell_config_unref0_ (GList* self);
static gboolean __lambda4_ (MultiTermConfig* self);
static gboolean ___lambda4__gsource_func (gpointer self);
static void multi_term_config_finalize (MultiTermConfig* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _multi_term_shell_config_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (multi_term_shell_config_unref (var), NULL));
}


static void _g_list_free__multi_term_shell_config_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _multi_term_shell_config_unref0_, NULL);
	g_list_free (self);
}


MultiTermConfig* multi_term_config_construct (GType object_type, const gchar* filename) {
	MultiTermConfig* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (MultiTermConfig*) g_type_create_instance (object_type);
	_tmp0_ = filename;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filename);
	self->priv->_filename = _tmp1_;
	multi_term_config_reload (self);
	return self;
}


MultiTermConfig* multi_term_config_new (const gchar* filename) {
	return multi_term_config_construct (MULTI_TERM_TYPE_CONFIG, filename);
}


gboolean multi_term_config_store (MultiTermConfig* self) {
	gboolean result = FALSE;
	gchar* data = NULL;
	GKeyFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->kf;
	_tmp1_ = g_key_file_to_data (_tmp0_, NULL, NULL);
	data = _tmp1_;
	{
		const gchar* _tmp2_ = NULL;
		_tmp2_ = self->priv->_filename;
		g_file_set_contents (_tmp2_, data, (gssize) -1, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp3_ = FALSE;
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch0_g_file_error;
			}
			_g_free0 (data);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp3_;
		}
		result = FALSE;
		_g_free0 (data);
		return result;
	}
	goto __finally0;
	__catch0_g_file_error:
	{
		GError* err = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = _ ("Unable to save config file %s: %s");
		_tmp5_ = self->priv->_filename;
		_tmp6_ = err;
		_tmp7_ = _tmp6_->message;
		g_warning (_tmp4_, _tmp5_, _tmp7_);
		result = TRUE;
		_g_error_free0 (err);
		_g_free0 (data);
		return result;
	}
	__finally0:
	_g_free0 (data);
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp8_;
}


static gboolean __lambda4_ (MultiTermConfig* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = multi_term_config_store (self);
	result = _tmp0_;
	return result;
}


static gboolean ___lambda4__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda4_ ((MultiTermConfig*) self);
	return result;
}


void multi_term_config_store_eventually (MultiTermConfig* self) {
	g_return_if_fail (self != NULL);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda4__gsource_func, multi_term_config_ref (self), multi_term_config_unref);
}


void multi_term_config_reload (MultiTermConfig* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GKeyFile* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		gsize _tmp2_;
		gchar** _tmp3_ = NULL;
		GKeyFile* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		GKeyFile* _tmp19_ = NULL;
		gsize _tmp20_;
		gchar** _tmp21_ = NULL;
		_tmp0_ = g_key_file_new ();
		_g_key_file_unref0 (self->kf);
		self->kf = _tmp0_;
		_tmp1_ = self->kf;
		_tmp3_ = g_key_file_get_groups (_tmp1_, &_tmp2_);
		{
			gchar** group_collection = NULL;
			gint group_collection_length1 = 0;
			gint _group_collection_size_ = 0;
			gint group_it = 0;
			group_collection = _tmp3_;
			group_collection_length1 = _tmp2_;
			for (group_it = 0; group_it < _tmp2_; group_it = group_it + 1) {
				gchar* _tmp4_ = NULL;
				gchar* group = NULL;
				_tmp4_ = g_strdup (group_collection[group_it]);
				group = _tmp4_;
				{
					gchar** _tmp5_ = NULL;
					GKeyFile* _tmp6_ = NULL;
					const gchar* _tmp7_ = NULL;
					gsize _tmp8_;
					gchar** _tmp9_ = NULL;
					gint _tmp5__length1 = 0;
					gint __tmp5__size_ = 0;
					gchar** _tmp10_ = NULL;
					gint _tmp10__length1 = 0;
					GKeyFile* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					_tmp6_ = self->kf;
					_tmp7_ = group;
					_tmp9_ = g_key_file_get_keys (_tmp6_, _tmp7_, &_tmp8_, &_inner_error_);
					_tmp5_ = _tmp9_;
					_tmp5__length1 = _tmp8_;
					__tmp5__size_ = _tmp5__length1;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_free0 (group);
						group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch1_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch1_g_file_error;
						}
						_g_free0 (group);
						group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_tmp10_ = _tmp5_;
					_tmp10__length1 = _tmp5__length1;
					_tmp5_ = NULL;
					_tmp5__length1 = 0;
					{
						gchar** key_collection = NULL;
						gint key_collection_length1 = 0;
						gint _key_collection_size_ = 0;
						gint key_it = 0;
						key_collection = _tmp10_;
						key_collection_length1 = _tmp10__length1;
						for (key_it = 0; key_it < _tmp10__length1; key_it = key_it + 1) {
							gchar* _tmp11_ = NULL;
							gchar* key = NULL;
							_tmp11_ = g_strdup (key_collection[key_it]);
							key = _tmp11_;
							{
								GKeyFile* _tmp12_ = NULL;
								const gchar* _tmp13_ = NULL;
								const gchar* _tmp14_ = NULL;
								_tmp12_ = self->kf;
								_tmp13_ = group;
								_tmp14_ = key;
								g_key_file_remove_key (_tmp12_, _tmp13_, _tmp14_, &_inner_error_);
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									_g_free0 (key);
									key_collection = (_vala_array_free (key_collection, key_collection_length1, (GDestroyNotify) g_free), NULL);
									_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (group);
									group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch1_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch1_g_file_error;
									}
									_g_free0 (key);
									key_collection = (_vala_array_free (key_collection, key_collection_length1, (GDestroyNotify) g_free), NULL);
									_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (group);
									group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_g_free0 (key);
							}
						}
						key_collection = (_vala_array_free (key_collection, key_collection_length1, (GDestroyNotify) g_free), NULL);
					}
					_tmp15_ = self->kf;
					_tmp16_ = group;
					g_key_file_remove_group (_tmp15_, _tmp16_, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (group);
						group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch1_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch1_g_file_error;
						}
						_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (group);
						group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (group);
				}
			}
			group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp17_ = self->kf;
		_tmp18_ = self->priv->_filename;
		g_key_file_load_from_file (_tmp17_, _tmp18_, G_KEY_FILE_KEEP_COMMENTS | G_KEY_FILE_KEEP_TRANSLATIONS, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch1_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		__g_list_free__multi_term_shell_config_unref0_0 (self->priv->_shell_configs);
		self->priv->_shell_configs = NULL;
		_tmp19_ = self->kf;
		_tmp21_ = g_key_file_get_groups (_tmp19_, &_tmp20_);
		{
			gchar** section_collection = NULL;
			gint section_collection_length1 = 0;
			gint _section_collection_size_ = 0;
			gint section_it = 0;
			section_collection = _tmp21_;
			section_collection_length1 = _tmp20_;
			for (section_it = 0; section_it < _tmp20_; section_it = section_it + 1) {
				gchar* _tmp22_ = NULL;
				gchar* section = NULL;
				_tmp22_ = g_strdup (section_collection[section_it]);
				section = _tmp22_;
				{
					const gchar* _tmp23_ = NULL;
					gboolean _tmp24_ = FALSE;
					_tmp23_ = section;
					_tmp24_ = g_str_has_prefix (_tmp23_, "shell=");
					if (_tmp24_) {
						const gchar* _tmp25_ = NULL;
						MultiTermShellConfig* _tmp26_ = NULL;
						_tmp25_ = section;
						_tmp26_ = multi_term_shell_config_new (self, _tmp25_);
						self->priv->_shell_configs = g_list_append (self->priv->_shell_configs, _tmp26_);
					}
					_g_free0 (section);
				}
			}
			section_collection = (_vala_array_free (section_collection, section_collection_length1, (GDestroyNotify) g_free), NULL);
		}
	}
	goto __finally1;
	__catch1_g_key_file_error:
	{
		GError* err = NULL;
		const gchar* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		GError* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = _ ("Unable to load config file %s: %s");
		_tmp28_ = self->priv->_filename;
		_tmp29_ = err;
		_tmp30_ = _tmp29_->message;
		g_warning (_tmp27_, _tmp28_, _tmp30_);
		_g_error_free0 (err);
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* err = NULL;
		const gchar* _tmp31_ = NULL;
		const gchar* _tmp32_ = NULL;
		GError* _tmp33_ = NULL;
		const gchar* _tmp34_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp31_ = _ ("Unable to load config file %s: %s");
		_tmp32_ = self->priv->_filename;
		_tmp33_ = err;
		_tmp34_ = _tmp33_->message;
		g_warning (_tmp31_, _tmp32_, _tmp34_);
		_g_error_free0 (err);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


const gchar* multi_term_config_get_filename (MultiTermConfig* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filename;
	result = _tmp0_;
	return result;
}


gboolean multi_term_config_get_show_tabs (MultiTermConfig* self) {
	gboolean result;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		_tmp1_ = self->kf;
		_tmp2_ = g_key_file_get_boolean (_tmp1_, "general", "show_tabs", &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp3_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp3_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally2;
	__catch2_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = TRUE;
		_g_error_free0 (err);
		return result;
	}
	__finally2:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp4_;
}


void multi_term_config_set_show_tabs (MultiTermConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->kf;
	_tmp1_ = value;
	g_key_file_set_boolean (_tmp0_, "general", "show_tabs", _tmp1_);
	multi_term_config_store_eventually (self);
}


gchar* multi_term_config_get_external_terminal (MultiTermConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		_tmp1_ = self->kf;
		_tmp2_ = g_key_file_get_string (_tmp1_, "general", "external_terminal", &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch3_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp3_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally3;
	__catch3_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp4_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = g_strdup ("xterm");
		result = _tmp4_;
		_g_error_free0 (err);
		return result;
	}
	__finally3:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_config_set_external_terminal (MultiTermConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->kf;
	_tmp1_ = value;
	g_key_file_set_string (_tmp0_, "general", "external_terminal", _tmp1_);
	multi_term_config_store_eventually (self);
}


gchar* multi_term_config_get_location (MultiTermConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		_tmp1_ = self->kf;
		_tmp2_ = g_key_file_get_string (_tmp1_, "general", "location", &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch4_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp3_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally4;
	__catch4_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp4_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = g_strdup ("msgwin");
		result = _tmp4_;
		_g_error_free0 (err);
		return result;
	}
	__finally4:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_config_set_location (MultiTermConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->kf;
	_tmp1_ = value;
	g_key_file_set_string (_tmp0_, "general", "location", _tmp1_);
	multi_term_config_store_eventually (self);
}


GList* multi_term_config_get_shell_configs (MultiTermConfig* self) {
	GList* result;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_shell_configs;
	result = _tmp0_;
	return result;
}


static void multi_term_value_config_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void multi_term_value_config_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		multi_term_config_unref (value->data[0].v_pointer);
	}
}


static void multi_term_value_config_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = multi_term_config_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer multi_term_value_config_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* multi_term_value_config_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MultiTermConfig* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = multi_term_config_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* multi_term_value_config_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MultiTermConfig** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = multi_term_config_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* multi_term_param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	MultiTermParamSpecConfig* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MULTI_TERM_TYPE_CONFIG), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer multi_term_value_get_config (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_CONFIG), NULL);
	return value->data[0].v_pointer;
}


void multi_term_value_set_config (GValue* value, gpointer v_object) {
	MultiTermConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MULTI_TERM_TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		multi_term_config_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		multi_term_config_unref (old);
	}
}


void multi_term_value_take_config (GValue* value, gpointer v_object) {
	MultiTermConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MULTI_TERM_TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		multi_term_config_unref (old);
	}
}


static void multi_term_config_class_init (MultiTermConfigClass * klass) {
	multi_term_config_parent_class = g_type_class_peek_parent (klass);
	((MultiTermConfigClass *) klass)->finalize = multi_term_config_finalize;
	g_type_class_add_private (klass, sizeof (MultiTermConfigPrivate));
}


static void multi_term_config_instance_init (MultiTermConfig * self) {
	self->priv = MULTI_TERM_CONFIG_GET_PRIVATE (self);
	self->priv->_shell_configs = NULL;
	self->ref_count = 1;
}


static void multi_term_config_finalize (MultiTermConfig* obj) {
	MultiTermConfig * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MULTI_TERM_TYPE_CONFIG, MultiTermConfig);
	g_signal_handlers_destroy (self);
	_g_key_file_unref0 (self->kf);
	_g_free0 (self->priv->_filename);
	__g_list_free__multi_term_shell_config_unref0_0 (self->priv->_shell_configs);
}


GType multi_term_config_get_type (void) {
	static volatile gsize multi_term_config_type_id__volatile = 0;
	if (g_once_init_enter (&multi_term_config_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { multi_term_value_config_init, multi_term_value_config_free_value, multi_term_value_config_copy_value, multi_term_value_config_peek_pointer, "p", multi_term_value_config_collect_value, "p", multi_term_value_config_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MultiTermConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_term_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiTermConfig), 0, (GInstanceInitFunc) multi_term_config_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType multi_term_config_type_id;
		multi_term_config_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MultiTermConfig", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&multi_term_config_type_id__volatile, multi_term_config_type_id);
	}
	return multi_term_config_type_id__volatile;
}


gpointer multi_term_config_ref (gpointer instance) {
	MultiTermConfig* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void multi_term_config_unref (gpointer instance) {
	MultiTermConfig* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MULTI_TERM_CONFIG_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



