/* multiterm.h generated by valac 0.34.9, the Vala compiler, do not modify */


#ifndef __MULTITERM_H__
#define __MULTITERM_H__

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <geanyplugin.h>
#include <vte/vte.h>

G_BEGIN_DECLS


#define MULTI_TERM_TYPE_CONFIG (multi_term_config_get_type ())
#define MULTI_TERM_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_CONFIG, MultiTermConfig))
#define MULTI_TERM_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_CONFIG, MultiTermConfigClass))
#define MULTI_TERM_IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_CONFIG))
#define MULTI_TERM_IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_CONFIG))
#define MULTI_TERM_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_CONFIG, MultiTermConfigClass))

typedef struct _MultiTermConfig MultiTermConfig;
typedef struct _MultiTermConfigClass MultiTermConfigClass;
typedef struct _MultiTermConfigPrivate MultiTermConfigPrivate;

#define MULTI_TERM_TYPE_SHELL_CONFIG (multi_term_shell_config_get_type ())
#define MULTI_TERM_SHELL_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_SHELL_CONFIG, MultiTermShellConfig))
#define MULTI_TERM_SHELL_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_SHELL_CONFIG, MultiTermShellConfigClass))
#define MULTI_TERM_IS_SHELL_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_SHELL_CONFIG))
#define MULTI_TERM_IS_SHELL_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_SHELL_CONFIG))
#define MULTI_TERM_SHELL_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_SHELL_CONFIG, MultiTermShellConfigClass))

typedef struct _MultiTermShellConfig MultiTermShellConfig;
typedef struct _MultiTermShellConfigClass MultiTermShellConfigClass;

#define MULTI_TERM_TYPE_CONTEXT_MENU (multi_term_context_menu_get_type ())
#define MULTI_TERM_CONTEXT_MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_CONTEXT_MENU, MultiTermContextMenu))
#define MULTI_TERM_CONTEXT_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_CONTEXT_MENU, MultiTermContextMenuClass))
#define MULTI_TERM_IS_CONTEXT_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_CONTEXT_MENU))
#define MULTI_TERM_IS_CONTEXT_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_CONTEXT_MENU))
#define MULTI_TERM_CONTEXT_MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_CONTEXT_MENU, MultiTermContextMenuClass))

typedef struct _MultiTermContextMenu MultiTermContextMenu;
typedef struct _MultiTermContextMenuClass MultiTermContextMenuClass;
typedef struct _MultiTermContextMenuPrivate MultiTermContextMenuPrivate;

#define MULTI_TERM_TYPE_NOTEBOOK (multi_term_notebook_get_type ())
#define MULTI_TERM_NOTEBOOK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_NOTEBOOK, MultiTermNotebook))
#define MULTI_TERM_NOTEBOOK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_NOTEBOOK, MultiTermNotebookClass))
#define MULTI_TERM_IS_NOTEBOOK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_NOTEBOOK))
#define MULTI_TERM_IS_NOTEBOOK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_NOTEBOOK))
#define MULTI_TERM_NOTEBOOK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_NOTEBOOK, MultiTermNotebookClass))

typedef struct _MultiTermNotebook MultiTermNotebook;
typedef struct _MultiTermNotebookClass MultiTermNotebookClass;
typedef struct _MultiTermNotebookPrivate MultiTermNotebookPrivate;

#define MULTI_TERM_TYPE_TERMINAL (multi_term_terminal_get_type ())
#define MULTI_TERM_TERMINAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_TERMINAL, MultiTermTerminal))
#define MULTI_TERM_TERMINAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_TERMINAL, MultiTermTerminalClass))
#define MULTI_TERM_IS_TERMINAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_TERMINAL))
#define MULTI_TERM_IS_TERMINAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_TERMINAL))
#define MULTI_TERM_TERMINAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_TERMINAL, MultiTermTerminalClass))

typedef struct _MultiTermTerminal MultiTermTerminal;
typedef struct _MultiTermTerminalClass MultiTermTerminalClass;
typedef struct _MultiTermShellConfigPrivate MultiTermShellConfigPrivate;

#define MULTI_TERM_TYPE_TAB_LABEL (multi_term_tab_label_get_type ())
#define MULTI_TERM_TAB_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MULTI_TERM_TYPE_TAB_LABEL, MultiTermTabLabel))
#define MULTI_TERM_TAB_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MULTI_TERM_TYPE_TAB_LABEL, MultiTermTabLabelClass))
#define MULTI_TERM_IS_TAB_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MULTI_TERM_TYPE_TAB_LABEL))
#define MULTI_TERM_IS_TAB_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MULTI_TERM_TYPE_TAB_LABEL))
#define MULTI_TERM_TAB_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MULTI_TERM_TYPE_TAB_LABEL, MultiTermTabLabelClass))

typedef struct _MultiTermTabLabel MultiTermTabLabel;
typedef struct _MultiTermTabLabelClass MultiTermTabLabelClass;
typedef struct _MultiTermTabLabelPrivate MultiTermTabLabelPrivate;
typedef struct _MultiTermTerminalPrivate MultiTermTerminalPrivate;

struct _MultiTermConfig {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MultiTermConfigPrivate * priv;
	GKeyFile* kf;
};

struct _MultiTermConfigClass {
	GTypeClass parent_class;
	void (*finalize) (MultiTermConfig *self);
};

struct _MultiTermContextMenu {
	GtkMenu parent_instance;
	MultiTermContextMenuPrivate * priv;
};

struct _MultiTermContextMenuClass {
	GtkMenuClass parent_class;
};

struct _MultiTermNotebook {
	GtkNotebook parent_instance;
	MultiTermNotebookPrivate * priv;
	MultiTermConfig* cfg;
};

struct _MultiTermNotebookClass {
	GtkNotebookClass parent_class;
};

struct _MultiTermShellConfig {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MultiTermShellConfigPrivate * priv;
	MultiTermConfig* _cfg;
};

struct _MultiTermShellConfigClass {
	GTypeClass parent_class;
	void (*finalize) (MultiTermShellConfig *self);
};

struct _MultiTermTabLabel {
	GtkHBox parent_instance;
	MultiTermTabLabelPrivate * priv;
	GtkLabel* label;
};

struct _MultiTermTabLabelClass {
	GtkHBoxClass parent_class;
};

struct _MultiTermTerminal {
	GtkFrame parent_instance;
	MultiTermTerminalPrivate * priv;
	VteTerminal* terminal;
};

struct _MultiTermTerminalClass {
	GtkFrameClass parent_class;
};


gpointer multi_term_config_ref (gpointer instance);
void multi_term_config_unref (gpointer instance);
GParamSpec* multi_term_param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void multi_term_value_set_config (GValue* value, gpointer v_object);
void multi_term_value_take_config (GValue* value, gpointer v_object);
gpointer multi_term_value_get_config (const GValue* value);
GType multi_term_config_get_type (void) G_GNUC_CONST;
MultiTermConfig* multi_term_config_new (const gchar* filename);
MultiTermConfig* multi_term_config_construct (GType object_type, const gchar* filename);
gboolean multi_term_config_store (MultiTermConfig* self);
void multi_term_config_store_eventually (MultiTermConfig* self);
void multi_term_config_reload (MultiTermConfig* self);
const gchar* multi_term_config_get_filename (MultiTermConfig* self);
gboolean multi_term_config_get_show_tabs (MultiTermConfig* self);
void multi_term_config_set_show_tabs (MultiTermConfig* self, gboolean value);
gchar* multi_term_config_get_external_terminal (MultiTermConfig* self);
void multi_term_config_set_external_terminal (MultiTermConfig* self, const gchar* value);
gchar* multi_term_config_get_location (MultiTermConfig* self);
void multi_term_config_set_location (MultiTermConfig* self, const gchar* value);
gpointer multi_term_shell_config_ref (gpointer instance);
void multi_term_shell_config_unref (gpointer instance);
GParamSpec* multi_term_param_spec_shell_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void multi_term_value_set_shell_config (GValue* value, gpointer v_object);
void multi_term_value_take_shell_config (GValue* value, gpointer v_object);
gpointer multi_term_value_get_shell_config (const GValue* value);
GType multi_term_shell_config_get_type (void) G_GNUC_CONST;
GList* multi_term_config_get_shell_configs (MultiTermConfig* self);
GType multi_term_context_menu_get_type (void) G_GNUC_CONST;
MultiTermContextMenu* multi_term_context_menu_new (MultiTermConfig* cfg);
MultiTermContextMenu* multi_term_context_menu_construct (GType object_type, MultiTermConfig* cfg);
#define MULTI_TERM_default_config "######################################################################" \
"##\n" \
"# MultiTerm Configuration File                                        " \
" #\n" \
"#=====================================================================" \
"=#\n" \
"#                                                                     " \
" #\n" \
"# You can configure the behaviour of the MultiTerm plugin by adjusting" \
" #\n" \
"# the values in this file.  Lines beginning with a # are considered   " \
" #\n" \
"# comments and are left as is.  Group/section names go in [] and keys " \
" #\n" \
"# and values are separated by an = symbol.  Where more than one value " \
" #\n" \
"# can be supplied, as in a list, separate the values with the ; symbol" \
".#\n" \
"#                                                                     " \
" #\n" \
"# Groups/section names beginning with 'shell=' denote a type of       " \
" #\n" \
"# terminal/shell that can be opened.  The name of the shell follows   " \
" #\n" \
"# the = symbol. Each shell can have it's own specific VTE             " \
" #\n" \
"# configuration and can run it's own child command.  As an example, if" \
" #\n" \
"# you wanted to use the Python interpreter shell instead of the       " \
" #\n" \
"# default shell, specify 'command=python'.                            " \
" #\n" \
"#                                                                     " \
" #\n" \
"# Keys/values commented out or empty values will cause MultiTerm to   " \
" #\n" \
"# use default values.                                                 " \
" #\n" \
"#                                                                     " \
" #\n" \
"######################################################################" \
"##\n" \
"\n" \
"#=====================================================================" \
"==\n" \
"# General Settings\n" \
"#=====================================================================" \
"==\n" \
"[general]\n" \
"\n" \
"# Where to put the multiterm notebook in the Geany user interface\n" \
"# one of: sidebar, msgwin\n" \
"location=msgwin\n" \
"\n" \
"# Make tabs take up as much space as is available\n" \
"full_width_tabs=true\n" \
"\n" \
"# Allow reordering of tabs\n" \
"reorderable_tabs=true\n" \
"\n" \
"# When there is only one tab left in the notebook, hide the tabs area\n" \
"hide_tabs_on_last=true\n" \
"\n" \
"# When launching an external terminal from the MultiTerm context menu," \
"\n" \
"# use this terminal.  Good choices include xterm, gnome-terminal,\n" \
"# xfce4-terminal or konsole.\n" \
"external_terminal=xterm\n" \
"\n" \
"# Save which shells were open when Geany closes and restore their\n" \
"# tabs when it restarts.\n" \
"save_tabs=false\n" \
"\n" \
"# Whether to show tabs or not\n" \
"show_tabs=true\n" \
"\n" \
"bg_color=#ffffff\n" \
"fg_color=#000000\n" \
"font=Monospace 9\n" \
"\n" \
"\n" \
"#=====================================================================" \
"==\n" \
"# Default Shell\n" \
"#=====================================================================" \
"==\n" \
"[shell=default]\n" \
"\n" \
"# This will be the tabs default tab label and won't change unless\n" \
"# track_title is set to true.\n" \
"name=Default Shell\n" \
"\n" \
"# This is the command to fork in the VTE, leave blank for default shel" \
"l\n" \
"command=\n" \
"\n" \
"# Make the tab's label track the VTE title\n" \
"track_title=true\n" \
"\n" \
"# Background color, foreground color and font for the VTE\n" \
"bg_color=#ffffff\n" \
"fg_color=#000000\n" \
"font=Monospace 9\n" \
"\n" \
"# Whether to allow bold fonts in the VTE\n" \
"#allow_bold=true\n" \
"\n" \
"# Whether to beep when the child outputs a bell sequence.\n" \
"#audible_bell=true\n" \
"\n" \
"# Controls whether the cursor blinks or not, one of:\n" \
"#   system (or blank), on, off\n" \
"#cursor_blink_mode=system\n" \
"\n" \
"# Controls the shape of the VTE cursor, one of:\n" \
"#   block, ibeam, underline\n" \
"#cursor_shape=block\n" \
"\n" \
"# Controls how erasing characters is handled, one of:\n" \
"#   auto, ascii_backspace, ascii_delete, delete_sequence, tty\n" \
"#backspace_binding=auto\n" \
"\n" \
"# Whether to hide the mouse pointer on key press if it's in the\n" \
"# terminal window\n" \
"#pointer_autohide=false\n" \
"\n" \
"# Scroll to the prompt at the bottom of the scrollback buffer on key\n" \
"# press\n" \
"#scroll_on_keystroke=true\n" \
"\n" \
"# Scroll to the bottom of the scrollback buffer when the child sends\n" \
"# output\n" \
"#scroll_on_output=false\n" \
"\n" \
"# The number of lines to keep in the scrollback buffer\n" \
"#scrollback_lines=512\n" \
"\n" \
"# Whether the terminal will present a visible bell when the child\n" \
"# sends a bell sequence.  The terminal will clear itself to the\n" \
"# default foreground color and then repaint itself.\n" \
"#visible_bell=false\n" \
"\n" \
"# When the user double-clicks to start selection, the terminal will\n" \
"# extend the selection on word boundaries. It will treat characters\n" \
"# the word-chars characters as parts of words, and all other\n" \
"# characters as word separators. Ranges of characters can be\n" \
"# specified by separating them with a hyphen.\n" \
"word_chars=-A-Za-z0-9,./\\\\?%&#:_\n" \
"\n" \
"\n" \
"#=====================================================================" \
"==\n" \
"# Other Shells\n" \
"#=====================================================================" \
"==\n" \
"\n" \
"# You can define additional shells just like the default shell but\n" \
"# using other commands and/or settings.\n" \
"\n" \
"#[shell=python]\n" \
"#name=Python Shell\n" \
"#command=python\n" \
"#track_title=false\n" \
"\n" \
"#[shell=irb]\n" \
"#name=Ruby Shell\n" \
"#command=irb\n" \
"#track_title=false\n"
GType multi_term_notebook_get_type (void) G_GNUC_CONST;
GType multi_term_terminal_get_type (void) G_GNUC_CONST;
MultiTermTerminal* multi_term_notebook_add_terminal (MultiTermNotebook* self, MultiTermShellConfig* cfg);
void multi_term_notebook_remove_terminal (MultiTermNotebook* self, gint tab_num);
MultiTermNotebook* multi_term_notebook_new (const gchar* config_filename);
MultiTermNotebook* multi_term_notebook_construct (GType object_type, const gchar* config_filename);
extern GeanyPlugin* geany_plugin;
extern GeanyData* geany_data;
extern GeanyFunctions* geany_functions;
gint plugin_version_check (gint abi_version);
void plugin_set_info (PluginInfo* info);
void plugin_init (GeanyData* data);
void plugin_cleanup (void);
MultiTermShellConfig* multi_term_shell_config_new (MultiTermConfig* cfg, const gchar* section);
MultiTermShellConfig* multi_term_shell_config_construct (GType object_type, MultiTermConfig* cfg, const gchar* section);
const gchar* multi_term_shell_config_get_section (MultiTermShellConfig* self);
gchar* multi_term_shell_config_get_name (MultiTermShellConfig* self);
void multi_term_shell_config_set_name (MultiTermShellConfig* self, const gchar* value);
gchar* multi_term_shell_config_get_command (MultiTermShellConfig* self);
void multi_term_shell_config_set_command (MultiTermShellConfig* self, const gchar* value);
gboolean multi_term_shell_config_get_track_title (MultiTermShellConfig* self);
void multi_term_shell_config_set_track_title (MultiTermShellConfig* self, gboolean value);
gchar* multi_term_shell_config_get_background_color (MultiTermShellConfig* self);
void multi_term_shell_config_set_background_color (MultiTermShellConfig* self, const gchar* value);
gchar* multi_term_shell_config_get_foreground_color (MultiTermShellConfig* self);
void multi_term_shell_config_set_foreground_color (MultiTermShellConfig* self, const gchar* value);
gchar* multi_term_shell_config_get_font (MultiTermShellConfig* self);
void multi_term_shell_config_set_font (MultiTermShellConfig* self, const gchar* value);
gboolean multi_term_shell_config_get_allow_bold (MultiTermShellConfig* self);
void multi_term_shell_config_set_allow_bold (MultiTermShellConfig* self, gboolean value);
gboolean multi_term_shell_config_get_audible_bell (MultiTermShellConfig* self);
void multi_term_shell_config_set_audible_bell (MultiTermShellConfig* self, gboolean value);
VteTerminalCursorBlinkMode multi_term_shell_config_get_cursor_blink_mode (MultiTermShellConfig* self);
void multi_term_shell_config_set_cursor_blink_mode (MultiTermShellConfig* self, VteTerminalCursorBlinkMode value);
VteTerminalCursorShape multi_term_shell_config_get_cursor_shape (MultiTermShellConfig* self);
void multi_term_shell_config_set_cursor_shape (MultiTermShellConfig* self, VteTerminalCursorShape value);
VteTerminalEraseBinding multi_term_shell_config_get_backspace_binding (MultiTermShellConfig* self);
void multi_term_shell_config_set_backspace_binding (MultiTermShellConfig* self, VteTerminalEraseBinding value);
gboolean multi_term_shell_config_get_pointer_autohide (MultiTermShellConfig* self);
void multi_term_shell_config_set_pointer_autohide (MultiTermShellConfig* self, gboolean value);
gboolean multi_term_shell_config_get_scroll_on_keystroke (MultiTermShellConfig* self);
void multi_term_shell_config_set_scroll_on_keystroke (MultiTermShellConfig* self, gboolean value);
gboolean multi_term_shell_config_get_scroll_on_output (MultiTermShellConfig* self);
void multi_term_shell_config_set_scroll_on_output (MultiTermShellConfig* self, gboolean value);
gint multi_term_shell_config_get_scrollback_lines (MultiTermShellConfig* self);
void multi_term_shell_config_set_scrollback_lines (MultiTermShellConfig* self, gint value);
gboolean multi_term_shell_config_get_visible_bell (MultiTermShellConfig* self);
void multi_term_shell_config_set_visible_bell (MultiTermShellConfig* self, gboolean value);
gchar* multi_term_shell_config_get_word_chars (MultiTermShellConfig* self);
void multi_term_shell_config_set_word_chars (MultiTermShellConfig* self, const gchar* value);
GType multi_term_tab_label_get_type (void) G_GNUC_CONST;
MultiTermTabLabel* multi_term_tab_label_new (const gchar* text);
MultiTermTabLabel* multi_term_tab_label_construct (GType object_type, const gchar* text);
const gchar* multi_term_tab_label_get_text (MultiTermTabLabel* self);
void multi_term_tab_label_set_text (MultiTermTabLabel* self, const gchar* value);
GtkButton* multi_term_tab_label_get_button (MultiTermTabLabel* self);
void multi_term_terminal_run_command (MultiTermTerminal* self, const gchar* command);
void multi_term_terminal_send_command (MultiTermTerminal* self, const gchar* command);
MultiTermTerminal* multi_term_terminal_new (MultiTermShellConfig* sh);
MultiTermTerminal* multi_term_terminal_construct (GType object_type, MultiTermShellConfig* sh);
const gchar* multi_term_terminal_get_tab_label_text (MultiTermTerminal* self);
void multi_term_terminal_set_tab_label_text (MultiTermTerminal* self, const gchar* value);
void multi_term_terminal_set_background_color (MultiTermTerminal* self, const gchar* value);
void multi_term_terminal_set_foreground_color (MultiTermTerminal* self, const gchar* value);


G_END_DECLS

#endif
