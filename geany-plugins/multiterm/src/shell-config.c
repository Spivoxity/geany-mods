/* shell-config.c generated by valac 0.34.9, the Vala compiler
 * generated from shell-config.vala, do not modify */

/*
 * shell-config.vala - This file is part of the Geany MultiTerm plugin
 *
 * Copyright (c) 2012 Matthew Brush <matt@geany.org>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include "multiterm.h"
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <vte/vte.h>
#include <gobject/gvaluecollector.h>

#define _multi_term_config_unref0(var) ((var == NULL) ? NULL : (var = (multi_term_config_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _MultiTermParamSpecShellConfig MultiTermParamSpecShellConfig;

struct _MultiTermShellConfigPrivate {
	gchar* _section;
};

struct _MultiTermParamSpecShellConfig {
	GParamSpec parent_instance;
};


static gpointer multi_term_shell_config_parent_class = NULL;

#define MULTI_TERM_SHELL_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MULTI_TERM_TYPE_SHELL_CONFIG, MultiTermShellConfigPrivate))
enum  {
	MULTI_TERM_SHELL_CONFIG_DUMMY_PROPERTY
};
#define MULTI_TERM_SHELL_CONFIG_warning_tmpl _ ("Unable to read value for '%s' key: %s")
MultiTermConfig* multi_term_shell_config_get_cfg (MultiTermShellConfig* self);
GKeyFile* multi_term_shell_config_get_kf (MultiTermShellConfig* self);
static void multi_term_shell_config_finalize (MultiTermShellConfig* obj);


static gpointer _multi_term_config_ref0 (gpointer self) {
	return self ? multi_term_config_ref (self) : NULL;
}


MultiTermShellConfig* multi_term_shell_config_construct (GType object_type, MultiTermConfig* cfg, const gchar* section) {
	MultiTermShellConfig* self = NULL;
	MultiTermConfig* _tmp0_ = NULL;
	MultiTermConfig* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (cfg != NULL, NULL);
	g_return_val_if_fail (section != NULL, NULL);
	self = (MultiTermShellConfig*) g_type_create_instance (object_type);
	_tmp0_ = cfg;
	_tmp1_ = _multi_term_config_ref0 (_tmp0_);
	_multi_term_config_unref0 (self->_cfg);
	self->_cfg = _tmp1_;
	_tmp2_ = section;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->_section);
	self->priv->_section = _tmp3_;
	return self;
}


MultiTermShellConfig* multi_term_shell_config_new (MultiTermConfig* cfg, const gchar* section) {
	return multi_term_shell_config_construct (MULTI_TERM_TYPE_SHELL_CONFIG, cfg, section);
}


MultiTermConfig* multi_term_shell_config_get_cfg (MultiTermShellConfig* self) {
	MultiTermConfig* result;
	MultiTermConfig* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_cfg;
	result = _tmp0_;
	return result;
}


GKeyFile* multi_term_shell_config_get_kf (MultiTermShellConfig* self) {
	GKeyFile* result;
	MultiTermConfig* _tmp0_ = NULL;
	MultiTermConfig* _tmp1_ = NULL;
	GKeyFile* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = multi_term_shell_config_get_cfg (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_->kf;
	result = _tmp2_;
	return result;
}


const gchar* multi_term_shell_config_get_section (MultiTermShellConfig* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_section;
	result = _tmp0_;
	return result;
}


gchar* multi_term_shell_config_get_name (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "name", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch7_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally7;
	__catch7_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("Default");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally7:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_name (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "name", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gchar* multi_term_shell_config_get_command (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "command", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch8_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally8;
	__catch8_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("sh");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally8:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_command (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "command", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_track_title (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "track_title", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch9_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally9;
	__catch9_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = TRUE;
		_g_error_free0 (err);
		return result;
	}
	__finally9:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_track_title (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "track_title", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gchar* multi_term_shell_config_get_background_color (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "bg_color", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch10_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally10;
	__catch10_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("#ffffff");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally10:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_background_color (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "bg_color", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gchar* multi_term_shell_config_get_foreground_color (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "fg_color", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch11_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally11;
	__catch11_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("#000000");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally11:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_foreground_color (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "fg_color", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gchar* multi_term_shell_config_get_font (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "font", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch12_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally12;
	__catch12_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("Monospace 9");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally12:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_font (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "font", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_allow_bold (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "allow_bold", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch13_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally13;
	__catch13_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = TRUE;
		_g_error_free0 (err);
		return result;
	}
	__finally13:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_allow_bold (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "allow_bold", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_audible_bell (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "audible_bell", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch14_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally14;
	__catch14_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = TRUE;
		_g_error_free0 (err);
		return result;
	}
	__finally14:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_audible_bell (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "audible_bell", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


VteTerminalCursorBlinkMode multi_term_shell_config_get_cursor_blink_mode (MultiTermShellConfig* self) {
	VteTerminalCursorBlinkMode result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* blink_mode = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		const gchar* _tmp10_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "cursor_blink_mode", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch15_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		_tmp6_ = _tmp5_;
		_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) -1);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		blink_mode = _tmp8_;
		_tmp10_ = blink_mode;
		if (g_strcmp0 (_tmp10_, "on") == 0) {
			_tmp9_ = TRUE;
		} else {
			const gchar* _tmp11_ = NULL;
			_tmp11_ = blink_mode;
			_tmp9_ = g_strcmp0 (_tmp11_, "true") == 0;
		}
		if (_tmp9_) {
			result = VTE_CURSOR_BLINK_ON;
			_g_free0 (blink_mode);
			_g_free0 (_tmp0_);
			return result;
		} else {
			gboolean _tmp12_ = FALSE;
			const gchar* _tmp13_ = NULL;
			_tmp13_ = blink_mode;
			if (g_strcmp0 (_tmp13_, "off") == 0) {
				_tmp12_ = TRUE;
			} else {
				const gchar* _tmp14_ = NULL;
				_tmp14_ = blink_mode;
				_tmp12_ = g_strcmp0 (_tmp14_, "false") == 0;
			}
			if (_tmp12_) {
				result = VTE_CURSOR_BLINK_OFF;
				_g_free0 (blink_mode);
				_g_free0 (_tmp0_);
				return result;
			} else {
				result = VTE_CURSOR_BLINK_SYSTEM;
				_g_free0 (blink_mode);
				_g_free0 (_tmp0_);
				return result;
			}
		}
		_g_free0 (blink_mode);
		_g_free0 (_tmp0_);
	}
	goto __finally15;
	__catch15_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = VTE_CURSOR_BLINK_SYSTEM;
		_g_error_free0 (err);
		return result;
	}
	__finally15:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return 0;
}


void multi_term_shell_config_set_cursor_blink_mode (MultiTermShellConfig* self, VteTerminalCursorBlinkMode value) {
	VteTerminalCursorBlinkMode _tmp0_ = 0;
	MultiTermConfig* _tmp10_ = NULL;
	MultiTermConfig* _tmp11_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	switch (_tmp0_) {
		case VTE_CURSOR_BLINK_ON:
		{
			GKeyFile* _tmp1_ = NULL;
			GKeyFile* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			_tmp1_ = multi_term_shell_config_get_kf (self);
			_tmp2_ = _tmp1_;
			_tmp3_ = self->priv->_section;
			g_key_file_set_string (_tmp2_, _tmp3_, "cursor_blink_mode", "on");
			break;
		}
		case VTE_CURSOR_BLINK_OFF:
		{
			GKeyFile* _tmp4_ = NULL;
			GKeyFile* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp4_ = multi_term_shell_config_get_kf (self);
			_tmp5_ = _tmp4_;
			_tmp6_ = self->priv->_section;
			g_key_file_set_string (_tmp5_, _tmp6_, "cursor_blink_mode", "off");
			break;
		}
		default:
		{
			GKeyFile* _tmp7_ = NULL;
			GKeyFile* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			_tmp7_ = multi_term_shell_config_get_kf (self);
			_tmp8_ = _tmp7_;
			_tmp9_ = self->priv->_section;
			g_key_file_set_string (_tmp8_, _tmp9_, "cursor_blink_mode", "system");
			break;
		}
	}
	_tmp10_ = multi_term_shell_config_get_cfg (self);
	_tmp11_ = _tmp10_;
	multi_term_config_store_eventually (_tmp11_);
}


VteTerminalCursorShape multi_term_shell_config_get_cursor_shape (MultiTermShellConfig* self) {
	VteTerminalCursorShape result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* shape = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "cursor_shape", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch16_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		_tmp6_ = _tmp5_;
		_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) -1);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		shape = _tmp8_;
		_tmp9_ = shape;
		if (g_strcmp0 (_tmp9_, "ibeam") == 0) {
			result = VTE_CURSOR_SHAPE_IBEAM;
			_g_free0 (shape);
			_g_free0 (_tmp0_);
			return result;
		} else {
			const gchar* _tmp10_ = NULL;
			_tmp10_ = shape;
			if (g_strcmp0 (_tmp10_, "underline") == 0) {
				result = VTE_CURSOR_SHAPE_UNDERLINE;
				_g_free0 (shape);
				_g_free0 (_tmp0_);
				return result;
			} else {
				result = VTE_CURSOR_SHAPE_BLOCK;
				_g_free0 (shape);
				_g_free0 (_tmp0_);
				return result;
			}
		}
		_g_free0 (shape);
		_g_free0 (_tmp0_);
	}
	goto __finally16;
	__catch16_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = VTE_CURSOR_SHAPE_BLOCK;
		_g_error_free0 (err);
		return result;
	}
	__finally16:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return 0;
}


void multi_term_shell_config_set_cursor_shape (MultiTermShellConfig* self, VteTerminalCursorShape value) {
	VteTerminalCursorShape _tmp0_ = 0;
	MultiTermConfig* _tmp10_ = NULL;
	MultiTermConfig* _tmp11_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	switch (_tmp0_) {
		case VTE_CURSOR_SHAPE_IBEAM:
		{
			GKeyFile* _tmp1_ = NULL;
			GKeyFile* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			_tmp1_ = multi_term_shell_config_get_kf (self);
			_tmp2_ = _tmp1_;
			_tmp3_ = self->priv->_section;
			g_key_file_set_string (_tmp2_, _tmp3_, "cursor_shape", "ibeam");
			break;
		}
		case VTE_CURSOR_SHAPE_UNDERLINE:
		{
			GKeyFile* _tmp4_ = NULL;
			GKeyFile* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp4_ = multi_term_shell_config_get_kf (self);
			_tmp5_ = _tmp4_;
			_tmp6_ = self->priv->_section;
			g_key_file_set_string (_tmp5_, _tmp6_, "cursor_shape", "underline");
			break;
		}
		default:
		{
			GKeyFile* _tmp7_ = NULL;
			GKeyFile* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			_tmp7_ = multi_term_shell_config_get_kf (self);
			_tmp8_ = _tmp7_;
			_tmp9_ = self->priv->_section;
			g_key_file_set_string (_tmp8_, _tmp9_, "cursor_shape", "block");
			break;
		}
	}
	_tmp10_ = multi_term_shell_config_get_cfg (self);
	_tmp11_ = _tmp10_;
	multi_term_config_store_eventually (_tmp11_);
}


VteTerminalEraseBinding multi_term_shell_config_get_backspace_binding (MultiTermShellConfig* self) {
	VteTerminalEraseBinding result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* binding = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "backspace_binding", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch17_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		_tmp6_ = _tmp5_;
		_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) -1);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		binding = _tmp8_;
		_tmp9_ = binding;
		if (g_strcmp0 (_tmp9_, "ascii_backspace") == 0) {
			result = VTE_ERASE_ASCII_BACKSPACE;
			_g_free0 (binding);
			_g_free0 (_tmp0_);
			return result;
		} else {
			const gchar* _tmp10_ = NULL;
			_tmp10_ = binding;
			if (g_strcmp0 (_tmp10_, "ascii_delete") == 0) {
				result = VTE_ERASE_ASCII_DELETE;
				_g_free0 (binding);
				_g_free0 (_tmp0_);
				return result;
			} else {
				const gchar* _tmp11_ = NULL;
				_tmp11_ = binding;
				if (g_strcmp0 (_tmp11_, "delete_sequence") == 0) {
					result = VTE_ERASE_DELETE_SEQUENCE;
					_g_free0 (binding);
					_g_free0 (_tmp0_);
					return result;
				} else {
					const gchar* _tmp12_ = NULL;
					_tmp12_ = binding;
					if (g_strcmp0 (_tmp12_, "tty") == 0) {
						result = VTE_ERASE_TTY;
						_g_free0 (binding);
						_g_free0 (_tmp0_);
						return result;
					} else {
						result = VTE_ERASE_AUTO;
						_g_free0 (binding);
						_g_free0 (_tmp0_);
						return result;
					}
				}
			}
		}
		_g_free0 (binding);
		_g_free0 (_tmp0_);
	}
	goto __finally17;
	__catch17_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = VTE_ERASE_AUTO;
		_g_error_free0 (err);
		return result;
	}
	__finally17:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return 0;
}


void multi_term_shell_config_set_backspace_binding (MultiTermShellConfig* self, VteTerminalEraseBinding value) {
	VteTerminalEraseBinding _tmp0_ = 0;
	MultiTermConfig* _tmp16_ = NULL;
	MultiTermConfig* _tmp17_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	switch (_tmp0_) {
		case VTE_ERASE_ASCII_BACKSPACE:
		{
			GKeyFile* _tmp1_ = NULL;
			GKeyFile* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			_tmp1_ = multi_term_shell_config_get_kf (self);
			_tmp2_ = _tmp1_;
			_tmp3_ = self->priv->_section;
			g_key_file_set_string (_tmp2_, _tmp3_, "backspace_binding", "ascii_backspace");
			break;
		}
		case VTE_ERASE_ASCII_DELETE:
		{
			GKeyFile* _tmp4_ = NULL;
			GKeyFile* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp4_ = multi_term_shell_config_get_kf (self);
			_tmp5_ = _tmp4_;
			_tmp6_ = self->priv->_section;
			g_key_file_set_string (_tmp5_, _tmp6_, "backspace_binding", "ascii_delete");
			break;
		}
		case VTE_ERASE_DELETE_SEQUENCE:
		{
			GKeyFile* _tmp7_ = NULL;
			GKeyFile* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			_tmp7_ = multi_term_shell_config_get_kf (self);
			_tmp8_ = _tmp7_;
			_tmp9_ = self->priv->_section;
			g_key_file_set_string (_tmp8_, _tmp9_, "backspace_binding", "delete_sequence");
			break;
		}
		case VTE_ERASE_TTY:
		{
			GKeyFile* _tmp10_ = NULL;
			GKeyFile* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			_tmp10_ = multi_term_shell_config_get_kf (self);
			_tmp11_ = _tmp10_;
			_tmp12_ = self->priv->_section;
			g_key_file_set_string (_tmp11_, _tmp12_, "backspace_binding", "tty");
			break;
		}
		default:
		{
			GKeyFile* _tmp13_ = NULL;
			GKeyFile* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp13_ = multi_term_shell_config_get_kf (self);
			_tmp14_ = _tmp13_;
			_tmp15_ = self->priv->_section;
			g_key_file_set_string (_tmp14_, _tmp15_, "backspace_binding", "auto");
			break;
		}
	}
	_tmp16_ = multi_term_shell_config_get_cfg (self);
	_tmp17_ = _tmp16_;
	multi_term_config_store_eventually (_tmp17_);
}


gboolean multi_term_shell_config_get_pointer_autohide (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "pointer_autohide", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch18_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally18;
	__catch18_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = FALSE;
		_g_error_free0 (err);
		return result;
	}
	__finally18:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_pointer_autohide (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "pointer_autohide", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_scroll_on_keystroke (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "scroll_on_keystroke", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch19_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally19;
	__catch19_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = TRUE;
		_g_error_free0 (err);
		return result;
	}
	__finally19:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_scroll_on_keystroke (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "scroll_on_keystroke", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_scroll_on_output (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "scroll_on_output", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch20_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally20;
	__catch20_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = FALSE;
		_g_error_free0 (err);
		return result;
	}
	__finally20:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_scroll_on_output (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "scroll_on_output", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gint multi_term_shell_config_get_scrollback_lines (MultiTermShellConfig* self) {
	gint result;
	gint _tmp6_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	{
		gint _tmp0_ = 0;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_integer (_tmp2_, _tmp3_, "scrollback_lines", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gint _tmp5_ = 0;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch21_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally21;
	__catch21_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = 512;
		_g_error_free0 (err);
		return result;
	}
	__finally21:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_scrollback_lines (MultiTermShellConfig* self, gint value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_integer (_tmp1_, _tmp2_, "scrollback_lines", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gboolean multi_term_shell_config_get_visible_bell (MultiTermShellConfig* self) {
	gboolean result;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_boolean (_tmp2_, _tmp3_, "visible_bell", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp5_ = FALSE;
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch22_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp5_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally22;
	__catch22_g_key_file_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		result = FALSE;
		_g_error_free0 (err);
		return result;
	}
	__finally22:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp6_;
}


void multi_term_shell_config_set_visible_bell (MultiTermShellConfig* self, gboolean value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_boolean (_tmp1_, _tmp2_, "visible_bell", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


gchar* multi_term_shell_config_get_word_chars (MultiTermShellConfig* self) {
	gchar* result;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp1_ = multi_term_shell_config_get_kf (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_section;
		_tmp4_ = g_key_file_get_string (_tmp2_, _tmp3_, "word_chars", &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch23_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp5_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally23;
	__catch23_g_key_file_error:
	{
		GError* err = NULL;
		gchar* _tmp6_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = g_strdup ("");
		result = _tmp6_;
		_g_error_free0 (err);
		return result;
	}
	__finally23:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void multi_term_shell_config_set_word_chars (MultiTermShellConfig* self, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	MultiTermConfig* _tmp4_ = NULL;
	MultiTermConfig* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = multi_term_shell_config_get_kf (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_section;
	_tmp3_ = value;
	g_key_file_set_string (_tmp1_, _tmp2_, "word_chars", _tmp3_);
	_tmp4_ = multi_term_shell_config_get_cfg (self);
	_tmp5_ = _tmp4_;
	multi_term_config_store_eventually (_tmp5_);
}


static void multi_term_value_shell_config_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void multi_term_value_shell_config_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		multi_term_shell_config_unref (value->data[0].v_pointer);
	}
}


static void multi_term_value_shell_config_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = multi_term_shell_config_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer multi_term_value_shell_config_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* multi_term_value_shell_config_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MultiTermShellConfig* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = multi_term_shell_config_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* multi_term_value_shell_config_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MultiTermShellConfig** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = multi_term_shell_config_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* multi_term_param_spec_shell_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	MultiTermParamSpecShellConfig* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MULTI_TERM_TYPE_SHELL_CONFIG), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer multi_term_value_get_shell_config (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_SHELL_CONFIG), NULL);
	return value->data[0].v_pointer;
}


void multi_term_value_set_shell_config (GValue* value, gpointer v_object) {
	MultiTermShellConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_SHELL_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MULTI_TERM_TYPE_SHELL_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		multi_term_shell_config_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		multi_term_shell_config_unref (old);
	}
}


void multi_term_value_take_shell_config (GValue* value, gpointer v_object) {
	MultiTermShellConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MULTI_TERM_TYPE_SHELL_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MULTI_TERM_TYPE_SHELL_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		multi_term_shell_config_unref (old);
	}
}


static void multi_term_shell_config_class_init (MultiTermShellConfigClass * klass) {
	multi_term_shell_config_parent_class = g_type_class_peek_parent (klass);
	((MultiTermShellConfigClass *) klass)->finalize = multi_term_shell_config_finalize;
	g_type_class_add_private (klass, sizeof (MultiTermShellConfigPrivate));
}


static void multi_term_shell_config_instance_init (MultiTermShellConfig * self) {
	self->priv = MULTI_TERM_SHELL_CONFIG_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void multi_term_shell_config_finalize (MultiTermShellConfig* obj) {
	MultiTermShellConfig * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MULTI_TERM_TYPE_SHELL_CONFIG, MultiTermShellConfig);
	g_signal_handlers_destroy (self);
	_multi_term_config_unref0 (self->_cfg);
	_g_free0 (self->priv->_section);
}


GType multi_term_shell_config_get_type (void) {
	static volatile gsize multi_term_shell_config_type_id__volatile = 0;
	if (g_once_init_enter (&multi_term_shell_config_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { multi_term_value_shell_config_init, multi_term_value_shell_config_free_value, multi_term_value_shell_config_copy_value, multi_term_value_shell_config_peek_pointer, "p", multi_term_value_shell_config_collect_value, "p", multi_term_value_shell_config_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MultiTermShellConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_term_shell_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiTermShellConfig), 0, (GInstanceInitFunc) multi_term_shell_config_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType multi_term_shell_config_type_id;
		multi_term_shell_config_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MultiTermShellConfig", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&multi_term_shell_config_type_id__volatile, multi_term_shell_config_type_id);
	}
	return multi_term_shell_config_type_id__volatile;
}


gpointer multi_term_shell_config_ref (gpointer instance) {
	MultiTermShellConfig* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void multi_term_shell_config_unref (gpointer instance) {
	MultiTermShellConfig* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MULTI_TERM_SHELL_CONFIG_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



